package com.kpmg.core.workflow.servlets;

import com.adobe.granite.workflow.event.WorkflowEvent;
import com.day.cq.wcm.api.Page;
import com.day.cq.wcm.workflow.api.WcmWorkflowService;
import com.day.cq.workflow.exec.Workflow;
import com.kpmg.core.annotations.WorkflowCodeExcludeFromCodeCoverageReportGenerated;
import com.kpmg.core.config.EmailTemplates;
import com.kpmg.core.config.KPMGGlobal;
import com.kpmg.core.email.EmailService;
import com.kpmg.core.userpermission.UserGroupActions;
import com.kpmg.core.workflow.constants.WorkflowConstants;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.ResourceBundle;
import javax.jcr.Node;
import javax.jcr.NodeIterator;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.mail.EmailException;
import org.apache.sling.api.SlingException;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.HttpConstants;
import org.apache.sling.api.servlets.SlingAllMethodsServlet;
import org.apache.sling.i18n.ResourceBundleProvider;
import org.osgi.framework.Constants;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This servlet is used to send email to initiator to notify that the reviewer has reassigned to
 * author which is a step back operation.
 */
@Component(
    service = Servlet.class,
    property = {
      Constants.SERVICE_DESCRIPTION + "=KPMG - StepBackEmailServlet",
      "sling.servlet.methods=" + HttpConstants.METHOD_GET,
      "sling.servlet.resourceTypes=kpmg/components/structure/page",
      "sling.servlet.extensions=json",
      "sling.servlet.selectors=sendStepBackEmailToInitiator"
    })
@WorkflowCodeExcludeFromCodeCoverageReportGenerated
public class StepBackEmailServlet extends SlingAllMethodsServlet {

  /** Default serial version unique ID */
  private static final long serialVersionUID = 7231298871L;

  @Reference private transient UserGroupActions userGroupActions;
  @Reference private transient EmailService emailService;
  @Reference private transient WcmWorkflowService wcmWorkflowService;
  @Reference private transient EmailTemplates emailTemplatesConfig;
  private static final Logger LOGGER = LoggerFactory.getLogger(StepBackEmailServlet.class);

  @Reference(target = "(component.name=org.apache.sling.i18n.impl.JcrResourceBundleProvider)")
  private transient ResourceBundleProvider resourceBundleProvider;

  @Reference private transient KPMGGlobal globalConfig;

  @Override
  protected void doGet(
      final SlingHttpServletRequest request, final SlingHttpServletResponse response)
      throws ServletException, IOException {
    String path = StringUtils.EMPTY;
    final ResourceResolver resolver = request.getResourceResolver();
    try {
      path = request.getParameter("path");
      final String user = wcmWorkflowService.getWorkflowInstance(path).getInitiator();
      final String email = userGroupActions.getEmail(user);
      if (StringUtils.isNotEmpty(email)) {
        final Resource resource = resolver.getResource(path);
        if (resource != null) {
          final Page page = resource.adaptTo(Page.class);
          if (page != null) {
            final ResourceBundle resourceBundle =
                resourceBundleProvider.getResourceBundle(page.getLanguage(false));
            final Map<String, Object> tokens = new HashMap<>();
            tokens.put(
                "stepBackSubject",
                resourceBundle.getString("kpmg.workflow.aar.stepbackEmail.inboxNotification"));
            tokens.put(
                "message1", resourceBundle.getString("kpmg.workflow.stepbackEmail.message1"));
            tokens.put("payload", path);
            tokens.put("host.prefix", globalConfig.getDomainName());
            tokens.put(
                "autoGeneratedText", resourceBundle.getString("kpmg.workflow.autoGeneratedText"));
            tokens.put("viewInboxText", resourceBundle.getString("kpmg.workflow.viewInboxText"));
            emailService.sendEmailWithTextTemplate(
                emailTemplatesConfig.getEmailTemplatePath(WorkflowConstants.STEPBACK_EMAIL),
                tokens,
                new String[] {email},
                new String[] {});
          }
        }
      }
    } catch (EmailException e) {
      LOGGER.error("EmailException {} while sending the email from {}: ", e, getClass());
    } finally {
      removeConfirmActivationPropertyFromWFHistory(request, path, resolver);
    }
  }

  /**
   * Removes the confirm activation property from WF history.
   *
   * @param request the request
   * @param path the path
   * @param resolver the resolver
   */
  private void removeConfirmActivationPropertyFromWFHistory(
      final SlingHttpServletRequest request, final String path, final ResourceResolver resolver) {
    try {
      final Workflow workflow = wcmWorkflowService.getWorkflowInstance(path);
      if (null != workflow) {
        final String workflowHistoryPath = workflow.getId() + "/history";
        final Resource resource = request.getResourceResolver().getResource(workflowHistoryPath);
        if (resource != null) {
          final Node workflowHistoryNode = resource.adaptTo(Node.class);
          deletePropertyFromWFHistory(workflowHistoryNode, resolver);
        }
      }
    } catch (SlingException | IllegalStateException e) {
      LOGGER.error("Exception: ", e);
    }
  }

  /**
   * Delete property from WF history.
   *
   * @param workflowHistoryNode the workflow history node
   * @param resolver the resolver
   */
  private void deletePropertyFromWFHistory(
      final Node workflowHistoryNode, final ResourceResolver resolver) {
    if (null == resolver) {
      LOGGER.error("Resolver is null: ");
      return;
    }

    try {
      final NodeIterator itr = workflowHistoryNode.getNodes();
      while (itr.hasNext()) {
        final Node childNode = itr.nextNode();
        if (childNode.hasProperty("event")
            && StringUtils.contains(
                childNode.getProperty("event").getString(),
                WorkflowEvent.WORKFLOW_COMPLETED_EVENT)) {
          final String wihMetaData = childNode.getPath() + "/workItem/metaData";
          final Resource resource = resolver.getResource(wihMetaData);
          if (resource != null) {
            final Node metadata = resource.adaptTo(Node.class);
            if (metadata != null
                && metadata.hasProperty(WorkflowConstants.REVIEWER_GROUP)
                && metadata.hasProperty(WorkflowConstants.ACTIVATION_ON_COMPLETE)) {
              metadata.getProperty(WorkflowConstants.ACTIVATION_ON_COMPLETE).remove();
              final Session session = resolver.adaptTo(Session.class);
              if (session != null) {
                session.refresh(true);
                session.save();
              }
            }
          }
        }
      }
    } catch (RepositoryException e) {
      LOGGER.error("RepositoryException occured while deleting the property from WF history: ", e);
    }
  }
}
